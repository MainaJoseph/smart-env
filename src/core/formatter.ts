import { ValidationError, ValidationResult, EnvSchema } from '../types';

/**
 * Format validation results for console output
 */
export function formatValidationResult(result: ValidationResult): string {
  const lines: string[] = [];

  if (result.valid) {
    lines.push('✔ All environment variables are valid');
  } else {
    lines.push('✘ Environment validation failed:\n');
    lines.push(formatErrors(result.errors));
  }

  if (result.warnings.length > 0) {
    lines.push('\nWarnings:');
    result.warnings.forEach((warning) => {
      lines.push(`  ⚠ ${warning}`);
    });
  }

  return lines.join('\n');
}

/**
 * Format validation errors with detailed information
 */
export function formatErrors(errors: ValidationError[]): string {
  return errors
    .map((error) => {
      let msg = `  ✘ ${error.variable}\n    ${error.message}`;

      if (error.expected) {
        msg += `\n    Expected: ${error.expected}`;
      }

      if (error.received !== undefined && error.received !== 'undefined') {
        msg += `\n    Received: ${error.received}`;
      }

      return msg;
    })
    .join('\n\n');
}

/**
 * Generate .env.example content from schema
 */
export function generateEnvExample(schema: EnvSchema): string {
  const lines: string[] = [];

  lines.push('# Environment Variables Configuration');
  lines.push('# Generated by smart-env');
  lines.push('');

  for (const [key, config] of Object.entries(schema)) {
    // Add description if available
    if (config.description) {
      lines.push(`# ${config.description}`);
    }

    // Add type information
    const typeInfo = getTypeDescription(config);
    lines.push(`# Type: ${typeInfo}`);

    // Add required/optional indicator
    const requiredText = config.required !== false ? 'Required' : 'Optional';
    lines.push(`# ${requiredText}`);

    // Add default value if available
    if (config.default !== undefined) {
      lines.push(`# Default: ${config.default}`);
    }

    // Add the variable with example value or empty
    const exampleValue = getExampleValue(config);
    lines.push(`${key}=${exampleValue}`);
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Get type description for documentation
 */
function getTypeDescription(config: any): string {
  switch (config.type) {
    case 'string':
      return 'string';
    case 'number':
      return config.integer ? 'integer' : 'number';
    case 'boolean':
      return 'boolean (true/false, 1/0, yes/no)';
    case 'url':
      return config.protocols
        ? `URL (protocols: ${config.protocols.join(', ')})`
        : 'URL';
    case 'json':
      return 'JSON string';
    case 'enum':
      return `enum (${config.values.join(' | ')})`;
    default:
      return config.type;
  }
}

/**
 * Get an example value for .env.example
 */
function getExampleValue(config: any): string {
  if (config.default !== undefined) {
    return String(config.default);
  }

  switch (config.type) {
    case 'string':
      return '';
    case 'number':
      return '3000';
    case 'boolean':
      return 'true';
    case 'url':
      return 'https://example.com';
    case 'json':
      return '{"key":"value"}';
    case 'enum':
      return config.values[0] || '';
    default:
      return '';
  }
}

/**
 * Generate env.config.ts template
 */
export function generateEnvConfigTemplate(): string {
  return `import { createEnv } from 'smart-env';

export const env = createEnv({
  NODE_ENV: {
    type: 'enum',
    values: ['development', 'production', 'test'] as const,
    default: 'development',
    description: 'Application environment'
  },
  PORT: {
    type: 'number',
    default: 3000,
    description: 'Server port number'
  },
  DATABASE_URL: {
    type: 'url',
    required: true,
    description: 'Database connection URL'
  },
  API_KEY: {
    type: 'string',
    required: true,
    description: 'API authentication key'
  },
  DEBUG: {
    type: 'boolean',
    default: false,
    description: 'Enable debug mode'
  }
});

// Export typed environment variables
export type Env = typeof env;
`;
}

/**
 * Format suggestions for missing or invalid variables
 */
export function formatSuggestions(errors: ValidationError[]): string {
  const lines: string[] = [];

  lines.push('\nSuggested fixes:');
  lines.push('');

  errors.forEach((error) => {
    lines.push(`${error.variable}=<your-value-here>`);
  });

  return lines.join('\n');
}
